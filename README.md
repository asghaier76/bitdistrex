# The BFX challenge Submission summary

Based on the assigned challenge and the directions the included code used the Grenache module for communication

the designed architecture relied on using both Grenache http and ws

The server will handle receiving commands/requests as it gets generated by each client.

The client will submit a request to the http server for a specific commane (newOrder, removeOrder, updateOrder), the format of the command as it get typed in the cli of the client is as following

```
COMMAND ARGS[]
```

the commands can be be (newOrder, removeOrder, updateOrder), for each one of them here is the syntax (assuming all orders are COIN vs USD)

```
newOrder buy|sell coin amount price, e,g, newOrder buy BTC 1 12500

removeOrder orderId. e.g., removeOrder 91b10466-ed05-41f9-ac8f-93c0ac925a6e

updateOrder orderId buy|sell coin amount price, e,g, updateOrder 91b10466-ed05-41f9-ac8f-93c0ac925a6e buy BTC 1 12600

```

The server upon receiving the command will use the Grenache WS to publish the command to all subscribers, where all clients have already subscribed using Grenache PeerSub to receive propgated commands

Upon receiving a broadcasted message to all clients that subscribed the message gets parsed to identify what action is need to be performed (newOrder, removeOrder, updateOrder), then the corresponding orderbook fucntion in each instance is called to update the orderbook

## Limitations, things that still need further development
- Using Grenache required from me some time to learn and understand how it works
- Due to the time limit, the matching engine mightn't be 100% correct
- Also, to ensure correct replication of all orders matching, some work still need to be done to have a version of dirty matched records before committing those matched records, so the approach is to propgate found matches to all clients based on their orderbooks and then find if reconcilation is needed or updates are needed to reflect the found matches and confirm removing matched reorcds
- The reconcilation of records can be easily witnessed if a client for example started after another client where previous records can not be replayed and added to the new client, so matching a record in client 1 will happen if a new order is submitted but the matchign order from client 2 will still be in the orderbook


# The BFX challenge

Hi and congratulations to your progress with Bitfinex!

Your task is to create a simplified distributed exchange

* Each client will have its own instance of the orderbook.
* Clients submit orders to their own instance of orderbook. The order is distributed to other instances, too.
* If a client's order matches with another order, any remainer is added to the orderbook, too.

Requirement:
* Code in Javascript
* Use Grenache for communication between nodes
* Simple order matching engine
* You don't need to create a UI or HTTP API

You should not spend more time than 6-8 hours on the task. We know that its probably not possible to complete the task 100% in the given time.


If you don't get to the end, just write up what is missing for a complete implementation of the task. Also, if your implementation has limitation and issues, that's no big deal. Just write everything down and indicate how you could solve them, given there was more time.

Good luck!

## Tips

 - you don't need to store state in a DB or filesystem
 - it is possible to solve the task with the node std lib, async and grenache libraries
 - beware of race conditions!
 - no need for express or any other http api layers

### Setting up the DHT

```
npm i -g grenache-grape
```

```
# boot two grape servers

grape --dp 20001 --aph 30001 --bn '127.0.0.1:20002'
grape --dp 20002 --aph 40001 --bn '127.0.0.1:20001'
```

### Setting up Grenache in your project

```
npm install --save grenache-nodejs-http
npm install --save grenache-nodejs-link
```


### Example RPC server / client with "Hello World"

```js
// This RPC server will announce itself as `rpc_test`
// in our Grape Bittorrent network
// When it receives requests, it will answer with 'world'

'use strict'

const { PeerRPCServer }  = require('grenache-nodejs-http')
const Link = require('grenache-nodejs-link')


const link = new Link({
  grape: 'http://127.0.0.1:30001'
})
link.start()

const peer = new PeerRPCServer(link, {
  timeout: 300000
})
peer.init()

const port = 1024 + Math.floor(Math.random() * 1000)
const service = peer.transport('server')
service.listen(port)

setInterval(function () {
  link.announce('rpc_test', service.port, {})
}, 1000)

service.on('request', (rid, key, payload, handler) => {
  console.log(payload) //  { msg: 'hello' }
  handler.reply(null, { msg: 'world' })
})

```

```js
// This client will as the DHT for a service called `rpc_test`
// and then establishes a P2P connection it.
// It will then send { msg: 'hello' } to the RPC server

'use strict'

const { PeerRPCClient }  = require('grenache-nodejs-http')
const Link = require('grenache-nodejs-link')

const link = new Link({
  grape: 'http://127.0.0.1:30001'
})
link.start()

const peer = new PeerRPCClient(link, {})
peer.init()

peer.request('rpc_test', { msg: 'hello' }, { timeout: 10000 }, (err, data) => {
  if (err) {
    console.error(err)
    process.exit(-1)
  }
  console.log(data) // { msg: 'world' }
})
```

### More Help

 - http://blog.bitfinex.com/tutorial/bitfinex-loves-microservices-grenache/
 - https://github.com/bitfinexcom/grenache-nodejs-example-fib-client
 - https://github.com/bitfinexcom/grenache-nodejs-example-fib-server
